name: Deploy to GCP

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to GCP VM
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.GCP_VM_IP }}
          username: ${{ secrets.GCP_VM_USER }}
          key: ${{ secrets.GCP_SSH_KEY }}
          command_timeout: 30m
          script: |
            set -e
            cd /home/${{ secrets.GCP_VM_USER }}/no-lose

            echo "=== Disk before cleanup ==="
            df -h / | tail -1

            # Stop all containers to free resources and allow full cleanup
            docker compose -f docker-compose.prod.yml down || true

            # Aggressive cleanup: remove ALL unused images (not just dangling), build cache, unused networks
            docker image prune -a -f 2>/dev/null || true
            docker builder prune -a -f 2>/dev/null || true
            docker system prune -a -f 2>/dev/null || true

            # Clear apt cache and temp files
            sudo apt-get clean 2>/dev/null || true
            sudo rm -rf /tmp/* 2>/dev/null || true
            sudo journalctl --vacuum-size=50M 2>/dev/null || true

            echo "=== Disk after cleanup ==="
            df -h / | tail -1

            # Pull latest code (reset local changes on server)
            git fetch origin main
            git reset --hard origin/main

            # Build and start all containers
            docker compose -f docker-compose.prod.yml up -d --build

            # Wait for postgres to be healthy (up to 90s)
            echo "Waiting for postgres..."
            for i in $(seq 1 30); do
              if docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U wa_user -d wa_database 2>/dev/null; then
                echo "Postgres is ready!"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "ERROR: Postgres failed to start"
                docker compose -f docker-compose.prod.yml logs --tail=20 postgres
                exit 1
              fi
              sleep 3
            done

            # Ensure wa_evolution database exists
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U wa_user -d wa_database -tc \
              "SELECT 1 FROM pg_database WHERE datname = 'wa_evolution'" | grep -q 1 || \
              docker compose -f docker-compose.prod.yml exec -T postgres psql -U wa_user -d wa_database -c \
              "CREATE DATABASE wa_evolution OWNER wa_user;"

            # Run database migrations
            docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head

            # Post-build cleanup
            docker image prune -f 2>/dev/null || true

            echo "=== Deploy complete ==="
            docker compose -f docker-compose.prod.yml ps
            df -h / | tail -1
