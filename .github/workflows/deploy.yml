name: Deploy to GCP

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to GCP VM
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.GCP_VM_IP }}
          username: ${{ secrets.GCP_VM_USER }}
          key: ${{ secrets.GCP_SSH_KEY }}
          command_timeout: 45m
          script: |
            set -e
            cd /home/${{ secrets.GCP_VM_USER }}/no-lose

            echo "=== Disk before deploy ==="
            df -h / | tail -1

            # Get latest code
            git fetch origin main
            git reset --hard origin/main

            # Free space only if disk usage > 80%
            DISK_USAGE=$(df / --output=pcent | tail -1 | tr -d ' %')
            if [ "$DISK_USAGE" -gt 80 ]; then
              echo "Disk usage ${DISK_USAGE}% > 80%, cleaning up..."
              docker image prune -f 2>/dev/null || true
              docker builder prune -f 2>/dev/null || true
              sudo apt-get clean 2>/dev/null || true
              sudo journalctl --vacuum-size=50M 2>/dev/null || true
              sudo rm -rf /tmp/.tmp-compose-* 2>/dev/null || true
            fi

            # Build new images using layer cache (fast if only code changed)
            docker compose -f docker-compose.prod.yml build backend
            docker compose -f docker-compose.prod.yml build frontend

            # Recreate containers with new images (zero-downtime for unchanged services)
            docker compose -f docker-compose.prod.yml up -d

            # Wait for postgres to be healthy
            echo "Waiting for postgres..."
            for i in $(seq 1 30); do
              if docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U wa_user -d wa_database 2>/dev/null; then
                echo "Postgres is ready!"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "ERROR: Postgres failed to start"
                docker compose -f docker-compose.prod.yml logs --tail=20 postgres
                exit 1
              fi
              sleep 3
            done

            # Ensure wa_evolution database exists
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U wa_user -d wa_database -tc \
              "SELECT 1 FROM pg_database WHERE datname = 'wa_evolution'" | grep -q 1 || \
              docker compose -f docker-compose.prod.yml exec -T postgres psql -U wa_user -d wa_database -c \
              "CREATE DATABASE wa_evolution OWNER wa_user;"

            # Run database migrations
            if ! docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head; then
              echo "Migration failed (tables may already exist). Stamping head to sync state."
              docker compose -f docker-compose.prod.yml exec -T backend alembic stamp head || true
            fi

            # Clean up old images left after rebuild
            docker image prune -f 2>/dev/null || true

            echo "=== Deploy complete ==="
            docker compose -f docker-compose.prod.yml ps
            df -h / | tail -1
